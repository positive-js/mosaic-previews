{"version":3,"mappings":"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","names":["uniqueAutocompleteIdCounter","McAutocompleteSelectedEvent","constructor","source","option","MC_AUTOCOMPLETE_DEFAULT_OPTIONS","InjectionToken","providedIn","factory","MC_AUTOCOMPLETE_DEFAULT_OPTIONS_FACTORY","autoActiveFirstOption","McAutocomplete","changeDetectorRef","elementRef","defaults","EventEmitter","_autoActiveFirstOption","_classList","value","length","split","forEach","className","trim","nativeElement","coerceBooleanProperty","_isOpen","showPanel","_openOnFocus","ngAfterContentInit","keyManager","ActiveDescendantKeyManager","options","setVisibility","setScrollTop","scrollTop","panel","getScrollTop","markForCheck","emitSelectEvent","event","optionSelected","emit","onKeydown","i0","McOption","McOptgroup","TemplateRef","provide","MC_OPTION_PARENT_COMPONENT","useExisting","i1","Component","selector","exportAs","templateUrl","styleUrls","host","class","encapsulation","ViewEncapsulation","changeDetection","ChangeDetectionStrategy","providers","Inject","template","ViewChild","static","ContentChildren","descendants","optionGroups","displayWith","Input","panelWidth","Output","opened","closed","classList","openOnFocus","McAutocompleteOrigin","Directive","AUTOCOMPLETE_OPTION_HEIGHT","AUTOCOMPLETE_PANEL_HEIGHT","AUTOCOMPLETE_BORDER_WIDTH","MC_AUTOCOMPLETE_SCROLL_STRATEGY","MC_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY","overlay","scrollStrategies","reposition","MC_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY_PROVIDER","deps","Overlay","useFactory","MAT_AUTOCOMPLETE_VALUE_ACCESSOR","NG_VALUE_ACCESSOR","forwardRef","McAutocompleteTrigger","multi","getMcAutocompleteMissingPanelError","Error","viewContainerRef","zone","scrollStrategy","dir","formField","document","viewportRuler","defer","autocomplete","merge","map","onSelectionChange","onStable","asObservable","pipe","take","switchMap","optionSelections","Subscription","Subject","canOpenOnNextFocus","activeElement","panelOpen","window","runOutsideAngular","addEventListener","windowBlurHandler","activeItem","overlayAttached","_autocompleteDisabled","ngOnDestroy","removeEventListener","viewportSubscription","unsubscribe","componentDestroyed","destroyPanel","closeKeyEventStream","complete","openPanel","attachOverlay","closePanel","isOpen","overlayRef","hasAttached","detach","closingActionsSubscription","detectChanges","updatePosition","tabOut","filter","getOutsideClickStream","detachments","observableOf","McOptionSelectionChange","writeValue","Promise","resolve","then","setTriggerValue","registerOnChange","fn","onChange","registerOnTouched","onTouched","setDisabledState","isDisabled","disabled","handleKeydown","keyCode","ESCAPE","preventDefault","activeOption","ENTER","selectViaInteraction","resetActiveItem","prevActiveItem","TAB","DOWN_ARROW","canOpen","isArrowKey","UP_ARROW","scrollToOption","handleInput","target","type","parseFloat","previousValue","handleFocus","handleClick","$event","fromEvent","clickTarget","_elementRef","customOrigin","connectedTo","contains","overlayElement","index","activeItemIndex","labelCount","countGroupLabelsBeforeOption","newScrollPosition","getOptionScrollPosition","subscribeToClosingActions","firstStable","optionChanges","changes","tap","positionStrategy","reapplyLastPosition","delay","wasOpen","panelClosingActions","subscribe","setValueAndClose","dispose","toDisplay","inputValue","control","clearPreviousSelectedOption","focus","skip","selected","deselect","portal","TemplatePortal","create","getOverlayConfig","keydownEvents","altKey","next","change","updateSize","width","getPanelWidth","position","getConfig","setOrigin","getConnectedElement","attach","OverlayConfig","getOverlayPosition","direction","flexibleConnectedTo","withFlexibleDimensions","withPush","withPositions","originX","originY","overlayX","overlayY","panelClass","getConnectedOverlayOrigin","getHostWidth","getBoundingClientRect","setFirstItemActive","setActiveItem","element","readOnly","i2","DOCUMENT","ctx","Optional","Host","autocompleteAttribute","autocompleteDisabled","McAutocompleteModule","McOptionModule","OverlayModule","McCommonModule","CommonModule","NgModule","imports","exports","declarations"],"sources":["webpack:///packages/mosaic/autocomplete/autocomplete.component.ts","webpack:///packages/mosaic/autocomplete/autocomplete.html","webpack:///packages/mosaic/autocomplete/autocomplete-origin.directive.ts","webpack:///packages/mosaic/autocomplete/autocomplete-trigger.directive.ts","webpack:///packages/mosaic/autocomplete/autocomplete.module.ts","webpack:///packages/mosaic/autocomplete/ptsecurity-mosaic-autocomplete.ts"],"sourcesContent":["import { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport {\n    AfterContentInit,\n    ChangeDetectionStrategy,\n    ChangeDetectorRef,\n    Component,\n    ContentChildren,\n    ElementRef,\n    EventEmitter,\n    Inject,\n    InjectionToken,\n    Input,\n    Output,\n    QueryList,\n    TemplateRef,\n    ViewChild,\n    ViewEncapsulation\n} from '@angular/core';\nimport { ActiveDescendantKeyManager } from '@ptsecurity/cdk/a11y';\nimport { MC_OPTION_PARENT_COMPONENT, McOptgroup, McOption } from '@ptsecurity/mosaic/core';\n\n\n/**\n * Autocomplete IDs need to be unique across components, so this counter exists outside of\n * the component definition.\n */\nlet uniqueAutocompleteIdCounter = 0;\n\nexport class McAutocompleteSelectedEvent {\n    constructor(public source: McAutocomplete, public option: McOption) {}\n}\n\n/** Default `mc-autocomplete` options that can be overridden. */\n// tslint:disable-next-line naming-convention\nexport interface McAutocompleteDefaultOptions {\n    /** Whether the first option should be highlighted when an autocomplete panel is opened. */\n    autoActiveFirstOption?: boolean;\n}\n\n/** Injection token to be used to override the default options for `mc-autocomplete`. */\nexport const MC_AUTOCOMPLETE_DEFAULT_OPTIONS =\n    new InjectionToken<McAutocompleteDefaultOptions>('mc-autocomplete-default-options', {\n        providedIn: 'root',\n        factory: MC_AUTOCOMPLETE_DEFAULT_OPTIONS_FACTORY\n    });\n\n// tslint:disable-next-line naming-convention\nexport function MC_AUTOCOMPLETE_DEFAULT_OPTIONS_FACTORY(): McAutocompleteDefaultOptions {\n    return { autoActiveFirstOption: true };\n}\n\n@Component({\n    selector: 'mc-autocomplete',\n    exportAs: 'mcAutocomplete',\n    templateUrl: 'autocomplete.html',\n    styleUrls: ['autocomplete.scss'],\n    host: {\n        class: 'mc-autocomplete'\n    },\n    encapsulation: ViewEncapsulation.None,\n    changeDetection: ChangeDetectionStrategy.OnPush,\n    providers: [{\n        provide: MC_OPTION_PARENT_COMPONENT, useExisting: McAutocomplete\n    }]\n})\nexport class McAutocomplete implements AfterContentInit {\n    /** Unique ID to be used by autocomplete trigger's \"aria-owns\" property. */\n    id: string = `mc-autocomplete-${uniqueAutocompleteIdCounter++}`;\n\n    /** Manages active item in option list based on key events. */\n    keyManager: ActiveDescendantKeyManager<McOption>;\n\n    /** Whether the autocomplete panel should be visible, depending on option length. */\n    showPanel: boolean = false;\n\n    @ViewChild(TemplateRef, {static: true}) template: TemplateRef<any>;\n\n    @ViewChild('panel', {static: false}) panel: ElementRef;\n\n    @ContentChildren(McOption, { descendants: true }) options: QueryList<McOption>;\n\n    @ContentChildren(McOptgroup) optionGroups: QueryList<McOptgroup>;\n\n    /** Function that maps an option's control value to its display value in the trigger. */\n    @Input() displayWith: ((value: any) => string) | null = null;\n\n    /**\n     * Specify the width of the autocomplete panel.  Can be any CSS sizing value, otherwise it will\n     * match the width of its host.\n     */\n    @Input() panelWidth: string | number;\n\n    /** Event that is emitted whenever an option from the list is selected. */\n    @Output() readonly optionSelected: EventEmitter<McAutocompleteSelectedEvent> =\n        new EventEmitter<McAutocompleteSelectedEvent>();\n\n    /** Event that is emitted when the autocomplete panel is opened. */\n    @Output() readonly opened: EventEmitter<void> = new EventEmitter<void>();\n\n    /** Event that is emitted when the autocomplete panel is closed. */\n    @Output() readonly closed: EventEmitter<void> = new EventEmitter<void>();\n\n    /**\n     * Takes classes set on the host mc-autocomplete element and applies them to the panel\n     * inside the overlay container to allow for easy styling.\n     */\n    @Input('class')\n    get classList() {\n        return this._classList;\n    }\n\n    set classList(value: string) {\n        if (value && value.length) {\n            value.split(' ')\n                .forEach((className) => this._classList[className.trim()] = true);\n\n            this.elementRef.nativeElement.className = '';\n        }\n    }\n\n    private _classList: any = {};\n\n    /**\n     * Whether the first option should be highlighted when the autocomplete panel is opened.\n     * Can be configured globally through the `MC_AUTOCOMPLETE_DEFAULT_OPTIONS` token.\n     */\n    @Input()\n    get autoActiveFirstOption(): boolean {\n        return this._autoActiveFirstOption;\n    }\n\n    set autoActiveFirstOption(value: boolean) {\n        this._autoActiveFirstOption = coerceBooleanProperty(value);\n    }\n\n    private _autoActiveFirstOption: boolean;\n\n    get isOpen(): boolean {\n        return this._isOpen && this.showPanel;\n    }\n\n    set isOpen(value: boolean) {\n        this._isOpen = value;\n    }\n\n    private _isOpen: boolean = false;\n\n    @Input()\n    get openOnFocus(): boolean {\n        return this._openOnFocus;\n    }\n\n    set openOnFocus(value: boolean) {\n        this._openOnFocus = value;\n    }\n\n    private _openOnFocus: boolean = true;\n\n    constructor(\n        private changeDetectorRef: ChangeDetectorRef,\n        private elementRef: ElementRef<HTMLElement>,\n        @Inject(MC_AUTOCOMPLETE_DEFAULT_OPTIONS) defaults: McAutocompleteDefaultOptions\n    ) {\n        this._autoActiveFirstOption = !!defaults.autoActiveFirstOption;\n    }\n\n    ngAfterContentInit() {\n        this.keyManager = new ActiveDescendantKeyManager<McOption>(this.options);\n        this.setVisibility();\n    }\n\n    setScrollTop(scrollTop: number): void {\n        if (this.panel) {\n            this.panel.nativeElement.scrollTop = scrollTop;\n        }\n    }\n\n    getScrollTop(): number {\n        return this.panel ? this.panel.nativeElement.scrollTop : 0;\n    }\n\n    setVisibility() {\n        this.showPanel = !!this.options.length;\n        this._classList['mc-autocomplete_visible'] = this.showPanel;\n        this._classList['mc-autocomplete_hidden'] = !this.showPanel;\n\n        this.changeDetectorRef.markForCheck();\n    }\n\n    emitSelectEvent(option: McOption): void {\n        const event = new McAutocompleteSelectedEvent(this, option);\n\n        this.optionSelected.emit(event);\n    }\n\n    onKeydown(event: KeyboardEvent): any {\n        this.keyManager.onKeydown(event);\n    }\n}\n\n","<ng-template>\n    <div class=\"mc-autocomplete-panel\" role=\"listbox\" [id]=\"id\" [ngClass]=\"classList\" #panel>\n        <ng-content></ng-content>\n    </div>\n</ng-template>\n","import { Directive, ElementRef } from '@angular/core';\n\n\n/**\n * Directive applied to an element to make it usable\n * as a connection point for an autocomplete panel.\n */\n@Directive({\n    selector: '[mcAutocompleteOrigin]',\n    exportAs: 'mcAutocompleteOrigin'\n})\nexport class McAutocompleteOrigin {\n    constructor(public elementRef: ElementRef<HTMLElement>) {}\n}\n","import { Directionality } from '@angular/cdk/bidi';\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport {\n    ConnectedPosition,\n    FlexibleConnectedPositionStrategy,\n    Overlay,\n    OverlayConfig,\n    OverlayRef,\n    PositionStrategy,\n    ScrollStrategy\n} from '@angular/cdk/overlay';\nimport { TemplatePortal } from '@angular/cdk/portal';\nimport { ViewportRuler } from '@angular/cdk/scrolling';\nimport { DOCUMENT } from '@angular/common';\nimport {\n    ChangeDetectorRef,\n    Directive,\n    ElementRef,\n    forwardRef,\n    Host,\n    Inject,\n    InjectionToken,\n    Input,\n    NgZone,\n    OnDestroy,\n    Optional,\n    ViewContainerRef\n} from '@angular/core';\nimport { ControlValueAccessor, NG_VALUE_ACCESSOR } from '@angular/forms';\nimport { DOWN_ARROW, ENTER, ESCAPE, TAB, UP_ARROW } from '@ptsecurity/cdk/keycodes';\nimport {\n    countGroupLabelsBeforeOption,\n    getOptionScrollPosition,\n    McOption,\n    McOptionSelectionChange\n} from '@ptsecurity/mosaic/core';\nimport { McFormField } from '@ptsecurity/mosaic/form-field';\nimport { Subscription, defer, fromEvent, merge, of as observableOf, Subject, Observable } from 'rxjs';\nimport { filter, take, switchMap, delay, tap, map } from 'rxjs/operators';\n\nimport { McAutocompleteOrigin } from './autocomplete-origin.directive';\nimport { McAutocomplete } from './autocomplete.component';\n\n\n/**\n * The following style constants are necessary to save here in order\n * to properly calculate the scrollTop of the panel. Because we are not\n * actually focusing the active item, scroll must be handled manually.\n */\n\n/** The height of each autocomplete option. */\nexport const AUTOCOMPLETE_OPTION_HEIGHT = 32;\n\n/** The total height of the autocomplete panel. */\nexport const AUTOCOMPLETE_PANEL_HEIGHT = 256;\n\nexport const AUTOCOMPLETE_BORDER_WIDTH: number = 2;\n\n/** Injection token that determines the scroll handling while the autocomplete panel is open. */\nexport const MC_AUTOCOMPLETE_SCROLL_STRATEGY =\n    new InjectionToken<() => ScrollStrategy>('mc-autocomplete-scroll-strategy');\n\n// tslint:disable-next-line naming-convention\nexport function MC_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY(overlay: Overlay): () => ScrollStrategy {\n    return () => overlay.scrollStrategies.reposition();\n}\n\nexport const MC_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY_PROVIDER = {\n    provide: MC_AUTOCOMPLETE_SCROLL_STRATEGY,\n    deps: [Overlay],\n    useFactory: MC_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY\n};\n\n/**\n * Provider that allows the autocomplete to register as a ControlValueAccessor.\n * @docs-private\n */\nexport const MAT_AUTOCOMPLETE_VALUE_ACCESSOR: any = {\n    provide: NG_VALUE_ACCESSOR,\n    useExisting: forwardRef(() => McAutocompleteTrigger),\n    multi: true\n};\n\n/**\n * Creates an error to be thrown when attempting to use an autocomplete trigger without a panel.\n * @docs-private\n */\nexport function getMcAutocompleteMissingPanelError(): Error {\n    return Error('Attempting to open an undefined instance of `mc-autocomplete`. ' +\n        'Make sure that the id passed to the `mcAutocomplete` is correct and that ' +\n        'you\\'re attempting to open it after the ngAfterContentInit hook.');\n}\n\n\n@Directive({\n    selector: `input[mcAutocomplete], textarea[mcAutocomplete]`,\n    host: {\n        class: 'mc-autocomplete-trigger',\n        '[attr.autocomplete]': 'autocompleteAttribute',\n        // Note: we use `focusin`, as opposed to `focus`, in order to open the panel\n        // a little earlier. This avoids issues where IE delays the focusing of the input.\n        '(focusin)': 'handleFocus()',\n        '(blur)': 'onTouched()',\n        '(input)': 'handleInput($event)',\n        '(keydown)': 'handleKeydown($event)',\n        '(click)': 'handleClick($event)'\n    },\n    exportAs: 'mcAutocompleteTrigger',\n    providers: [MAT_AUTOCOMPLETE_VALUE_ACCESSOR]\n})\nexport class McAutocompleteTrigger implements ControlValueAccessor, OnDestroy {\n    // @ts-ignore\n    readonly optionSelections: Observable<McOptionSelectionChange> = defer(() => {\n        if (this.autocomplete && this.autocomplete.options) {\n            return merge(...this.autocomplete.options.map((option) => option.onSelectionChange));\n        }\n\n        // If there are any subscribers before `ngAfterViewInit`, the `autocomplete` will be undefined.\n        // Return a stream that we'll replace with the real one once everything is in place.\n        return this.zone.onStable\n            .asObservable()\n            .pipe(take(1), switchMap(() => this.optionSelections));\n    });\n\n    /** The currently active option, coerced to MatOption type. */\n    get activeOption(): McOption | null {\n        if (this.autocomplete && this.autocomplete.keyManager) {\n            return this.autocomplete.keyManager.activeItem;\n        }\n\n        return null;\n    }\n\n    get panelOpen(): boolean {\n        return this.overlayAttached && this.autocomplete.showPanel;\n    }\n\n    /** The autocomplete panel to be attached to this trigger. */\n    @Input('mcAutocomplete') autocomplete: McAutocomplete;\n\n    /**\n     * Reference relative to which to position the autocomplete panel.\n     * Defaults to the autocomplete trigger element.\n     */\n    @Input('mcAutocompleteConnectedTo') connectedTo: McAutocompleteOrigin;\n\n    /**\n     * `autocomplete` attribute to be set on the input element.\n     * @docs-private\n     */\n    @Input('autocomplete') autocompleteAttribute: string = 'off';\n\n    /**\n     * Whether the autocomplete is disabled. When disabled, the element will\n     * act as a regular input and the user won't be able to open the panel.\n     */\n    @Input('mcAutocompleteDisabled')\n    get autocompleteDisabled(): boolean {\n        return this._autocompleteDisabled;\n    }\n\n    set autocompleteDisabled(value: boolean) {\n        this._autocompleteDisabled = coerceBooleanProperty(value);\n    }\n\n    private _autocompleteDisabled = false;\n\n    private overlayAttached: boolean = false;\n\n    private overlayRef: OverlayRef | null;\n\n    private portal: TemplatePortal;\n\n    private componentDestroyed = false;\n\n    private scrollStrategy: () => ScrollStrategy;\n\n    /** Old value of the native input. Used to work around issues with the `input` event on IE. */\n    private previousValue: string | number | null;\n\n    /** Strategy that is used to position the panel. */\n    private positionStrategy: FlexibleConnectedPositionStrategy;\n\n    /** The subscription for closing actions (some are bound to document). */\n    private closingActionsSubscription: Subscription;\n\n    /** Subscription to viewport size changes. */\n    private viewportSubscription = Subscription.EMPTY;\n\n    /**\n     * Whether the autocomplete can open the next time it is focused. Used to prevent a focused,\n     * closed autocomplete from being reopened if the user switches to another browser tab and then\n     * comes back.\n     */\n    private canOpenOnNextFocus = true;\n\n    /** Stream of keyboard events that can close the panel. */\n    private readonly closeKeyEventStream = new Subject<void>();\n\n    constructor(\n        private elementRef: ElementRef<HTMLInputElement>,\n        private viewContainerRef: ViewContainerRef,\n        private changeDetectorRef: ChangeDetectorRef,\n        private overlay: Overlay,\n        private zone: NgZone,\n        @Inject(MC_AUTOCOMPLETE_SCROLL_STRATEGY) scrollStrategy: any,\n        @Optional() private dir: Directionality,\n        @Optional() @Host() private formField: McFormField,\n        @Optional() @Inject(DOCUMENT) private document: any,\n        // @breaking-change 8.0.0 Make `_viewportRuler` required.\n        private viewportRuler?: ViewportRuler\n    ) {\n        // tslint:disable-next-line no-typeof-undefined\n        if (typeof window !== 'undefined') {\n            zone.runOutsideAngular(() => {\n                window.addEventListener('blur', this.windowBlurHandler);\n            });\n        }\n\n        this.scrollStrategy = scrollStrategy;\n    }\n\n    ngOnDestroy() {\n        // tslint:disable-next-line no-typeof-undefined\n        if (typeof window !== 'undefined') {\n            window.removeEventListener('blur', this.windowBlurHandler);\n        }\n\n        this.viewportSubscription.unsubscribe();\n        this.componentDestroyed = true;\n        this.destroyPanel();\n        this.closeKeyEventStream.complete();\n    }\n\n    /** `View -> model callback called when value changes` */\n    // tslint:disable-next-line no-empty\n    onChange: (value: any) => void = () => {};\n\n    /** `View -> model callback called when autocomplete has been touched` */\n    // tslint:disable-next-line no-empty\n    onTouched: () => void = () => {};\n\n    /** Opens the autocomplete suggestion panel. */\n    openPanel(): void {\n        this.attachOverlay();\n    }\n\n    closePanel(): void {\n        if (!this.overlayAttached) { return; }\n\n        if (this.panelOpen) {\n            this.autocomplete.closed.emit();\n        }\n\n        this.autocomplete.isOpen = this.overlayAttached = false;\n\n        if (this.overlayRef && this.overlayRef.hasAttached()) {\n            this.overlayRef.detach();\n            this.closingActionsSubscription.unsubscribe();\n        }\n\n        // Note that in some cases this can end up being called after the component is destroyed.\n        // Add a check to ensure that we don't try to run change detection on a destroyed view.\n        if (!this.componentDestroyed) {\n            // We need to trigger change detection manually, because\n            // `fromEvent` doesn't seem to do it at the proper time.\n            // This ensures that the label is reset when the\n            // user clicks outside.\n            this.changeDetectorRef.detectChanges();\n        }\n    }\n\n    /**\n     * Updates the position of the autocomplete suggestion panel to ensure that it fits all options\n     * within the viewport.\n     */\n    updatePosition(): void {\n        if (this.overlayAttached) {\n            this.overlayRef!.updatePosition();\n        }\n    }\n\n    /**\n     * A stream of actions that should close the autocomplete panel, including\n     * when an option is selected, on blur, and when TAB is pressed.\n     */\n    get panelClosingActions(): Observable<McOptionSelectionChange | null> {\n        return merge(\n            this.optionSelections,\n            this.autocomplete.keyManager.tabOut.pipe(filter(() => this.overlayAttached)),\n            this.closeKeyEventStream,\n            this.getOutsideClickStream(),\n            this.overlayRef ?\n                this.overlayRef.detachments().pipe(filter(() => this.overlayAttached)) :\n                observableOf()\n        ).pipe(\n            // Normalize the output so we return a consistent type.\n            map((event) => event instanceof McOptionSelectionChange ? event : null)\n        );\n    }\n\n    // Implemented as part of ControlValueAccessor.\n    writeValue(value: any): void {\n        Promise.resolve(null).then(() => this.setTriggerValue(value));\n    }\n\n    // Implemented as part of ControlValueAccessor.\n    registerOnChange(fn: (value: any) => {}): void {\n        this.onChange = fn;\n    }\n\n    // Implemented as part of ControlValueAccessor.\n    registerOnTouched(fn: () => {}) {\n        this.onTouched = fn;\n    }\n\n    // Implemented as part of ControlValueAccessor.\n    setDisabledState(isDisabled: boolean) {\n        this.elementRef.nativeElement.disabled = isDisabled;\n    }\n\n    handleKeydown(event: KeyboardEvent): void {\n        // tslint:disable-next-line deprecation\n        const keyCode = event.keyCode;\n\n        // Prevent the default action on all escape key presses. This is here primarily to bring IE\n        // in line with other browsers. By default, pressing escape on IE will cause it to revert\n        // the input value to the one that it had on focus, however it won't dispatch any events\n        // which means that the model value will be out of sync with the view.\n        if (keyCode === ESCAPE) {\n            event.preventDefault();\n        }\n\n        if (this.activeOption && keyCode === ENTER && this.panelOpen) {\n            this.activeOption.selectViaInteraction();\n            this.resetActiveItem();\n            event.preventDefault();\n        } else if (this.autocomplete) {\n            const prevActiveItem = this.autocomplete.keyManager.activeItem;\n\n            if (this.panelOpen || keyCode === TAB) {\n                this.autocomplete.onKeydown(event);\n            } else if (keyCode === DOWN_ARROW && this.canOpen()) {\n                this.openPanel();\n            }\n\n            const isArrowKey = keyCode === UP_ARROW || keyCode === DOWN_ARROW;\n\n            if (isArrowKey || this.autocomplete.keyManager.activeItem !== prevActiveItem) {\n                this.scrollToOption();\n            }\n        }\n    }\n\n    handleInput(event: KeyboardEvent): void {\n        const target = event.target as HTMLInputElement;\n        let value: number | string | null = target.value;\n\n        // Based on `NumberValueAccessor` from forms.\n        if (target.type === 'number') {\n            value = value === '' ? null : parseFloat(value);\n        }\n\n        // If the input has a placeholder, IE will fire the `input` event on page load,\n        // focus and blur, in addition to when the user actually changed the value. To\n        // filter out all of the extra events, we save the value on focus and between\n        // `input` events, and we check whether it changed.\n        // See: https://connect.microsoft.com/IE/feedback/details/885747/\n        if (this.previousValue !== value) {\n            this.previousValue = value;\n            this.onChange(value);\n\n            if (this.canOpen() && this.document.activeElement === event.target) {\n                this.openPanel();\n            }\n        }\n    }\n\n    handleFocus(): void {\n        if (!this.canOpenOnNextFocus) {\n            this.canOpenOnNextFocus = true;\n        } else if (this.canOpen() && this.autocomplete.openOnFocus) {\n            this.previousValue = this.elementRef.nativeElement.value;\n            this.attachOverlay();\n        }\n    }\n\n    handleClick($event: MouseEvent) {\n        if (this.canOpen() && this.document.activeElement === $event.target) {\n            this.openPanel();\n        }\n    }\n\n    /** Stream of clicks outside of the autocomplete panel. */\n    private getOutsideClickStream(): Observable<any> {\n        return merge(\n            // tslint:disable-next-line: no-unnecessary-type-assertion\n            fromEvent(this.document, 'click') as Observable<MouseEvent>,\n            // tslint:disable-next-line: no-unnecessary-type-assertion\n            fromEvent(this.document, 'touchend') as Observable<TouchEvent>\n        )\n            .pipe(filter((event) => {\n\n                const clickTarget = event.target as HTMLElement;\n                const formField = this.formField ? this.formField._elementRef.nativeElement : null;\n                const customOrigin = this.connectedTo ? this.connectedTo.elementRef.nativeElement : null;\n\n                return this.overlayAttached &&\n                    clickTarget !== this.elementRef.nativeElement &&\n                    (!formField || !formField.contains(clickTarget)) &&\n                    (!customOrigin || !customOrigin.contains(clickTarget)) &&\n                    (!!this.overlayRef && !this.overlayRef.overlayElement.contains(clickTarget));\n            }));\n    }\n\n    /**\n     * Event handler for when the window is blurred. Needs to be an\n     * arrow function in order to preserve the context.\n     */\n    private windowBlurHandler = () => {\n        // If the user blurred the window while the autocomplete is focused, it means that it'll be\n        // refocused when they come back. In this case we want to skip the first focus event, if the\n        // pane was closed, in order to avoid reopening it unintentionally.\n        this.canOpenOnNextFocus = this.document.activeElement !== this.elementRef.nativeElement || this.panelOpen;\n    }\n\n    /**\n     * Given that we are not actually focusing active options, we must manually adjust scroll\n     * to reveal options below the fold. First, we find the offset of the option from the top\n     * of the panel. If that offset is below the fold, the new scrollTop will be the offset -\n     * the panel height + the option height, so the active option will be just visible at the\n     * bottom of the panel. If that offset is above the top of the visible panel, the new scrollTop\n     * will become the offset. If that offset is visible within the panel already, the scrollTop is\n     * not adjusted.\n     */\n    private scrollToOption(): void {\n        const index = this.autocomplete.keyManager.activeItemIndex || 0;\n        const labelCount = countGroupLabelsBeforeOption(\n            index,\n            this.autocomplete.options, this.autocomplete.optionGroups\n        );\n\n        const newScrollPosition = getOptionScrollPosition(\n            index + labelCount,\n            AUTOCOMPLETE_OPTION_HEIGHT,\n            this.autocomplete.getScrollTop(),\n            AUTOCOMPLETE_PANEL_HEIGHT\n        );\n\n        this.autocomplete.setScrollTop(newScrollPosition);\n    }\n\n    /**\n     * This method listens to a stream of panel closing actions and resets the\n     * stream every time the option list changes.\n     */\n    private subscribeToClosingActions(): Subscription {\n        const firstStable = this.zone.onStable.asObservable()\n            .pipe(take(1));\n        const optionChanges = this.autocomplete.options.changes\n            .pipe(\n                tap(() => this.positionStrategy.reapplyLastPosition()),\n                // Defer emitting to the stream until the next tick, because changing\n                // bindings in here will cause \"changed after checked\" errors.\n                delay(0)\n            );\n\n        // When the zone is stable initially, and when the option list changes...\n        return merge(firstStable, optionChanges)\n            .pipe(\n                // create a new stream of panelClosingActions, replacing any previous streams\n                // that were created, and flatten it so our stream only emits closing events...\n                switchMap(() => {\n                    const wasOpen = this.panelOpen;\n                    this.resetActiveItem();\n                    this.autocomplete.setVisibility();\n\n                    if (this.panelOpen) {\n                        this.overlayRef!.updatePosition();\n\n                        // If the `panelOpen` state changed, we need to make sure to emit the `opened`\n                        // event, because we may not have emitted it when the panel was attached. This\n                        // can happen if the users opens the panel and there are no options, but the\n                        // options come in slightly later or as a result of the value changing.\n                        if (wasOpen !== this.panelOpen) {\n                            this.autocomplete.opened.emit();\n                        }\n                    }\n\n                    return this.panelClosingActions;\n                }),\n                // when the first closing event occurs...\n                take(1)\n            )\n            // set the value, close the panel, and complete.\n            .subscribe((event) => this.setValueAndClose(event));\n    }\n\n    /** Destroys the autocomplete suggestion panel. */\n    private destroyPanel(): void {\n        if (this.overlayRef) {\n            this.closePanel();\n            this.overlayRef.dispose();\n            this.overlayRef = null;\n        }\n    }\n\n    private setTriggerValue(value: any): void {\n        const toDisplay = this.autocomplete && this.autocomplete.displayWith ?\n            this.autocomplete.displayWith(value) :\n            value;\n\n        // Simply falling back to an empty string if the display value is falsy does not work properly.\n        // The display value can also be the number zero and shouldn't fall back to an empty string.\n        const inputValue = toDisplay != null ? toDisplay : '';\n\n        // If it's used within a `MatFormField`, we should set it through the property so it can go\n        // through change detection.\n        if (this.formField) {\n            this.formField.control.value = inputValue;\n        } else {\n            this.elementRef.nativeElement.value = inputValue;\n        }\n\n        this.previousValue = inputValue;\n    }\n\n    /** This method closes the panel, and if a value is specified, also sets the associated\n     * control to that value. It will also mark the control as dirty if this interaction\n     * stemmed from the user.\n     */\n    private setValueAndClose(event: McOptionSelectionChange | null): void {\n        if (event && event.source) {\n            this.clearPreviousSelectedOption(event.source);\n            this.setTriggerValue(event.source.value);\n            this.onChange(event.source.value);\n            this.elementRef.nativeElement.focus();\n\n            this.autocomplete.emitSelectEvent(event.source);\n        }\n\n        this.closePanel();\n    }\n\n    /** Clear any previous selected option and emit a selection change event for this option */\n    private clearPreviousSelectedOption(skip: McOption) {\n        this.autocomplete.options.forEach((option) => {\n            if (option !== skip && option.selected) {\n                option.deselect();\n            }\n        });\n    }\n\n    private attachOverlay(): void {\n        if (!this.autocomplete) {\n            throw getMcAutocompleteMissingPanelError();\n        }\n\n        let overlayRef = this.overlayRef;\n\n        if (!overlayRef) {\n            this.portal = new TemplatePortal(this.autocomplete.template, this.viewContainerRef);\n            overlayRef = this.overlay.create(this.getOverlayConfig());\n            this.overlayRef = overlayRef;\n\n            // Use the `keydownEvents` in order to take advantage of\n            // the overlay event targeting provided by the CDK overlay.\n            overlayRef.keydownEvents().subscribe((event) => {\n                // Close when pressing ESCAPE or ALT + UP_ARROW, based on the a11y guidelines.\n                // See: https://www.w3.org/TR/wai-aria-practices-1.1/#textbox-keyboard-interaction\n                // tslint:disable-next-line deprecation\n                if (event.keyCode === ESCAPE || (event.keyCode === UP_ARROW && event.altKey)) {\n                    this.resetActiveItem();\n                    this.closeKeyEventStream.next();\n                }\n            });\n\n            if (this.viewportRuler) {\n                this.viewportSubscription = this.viewportRuler.change().subscribe(() => {\n                    if (this.panelOpen && overlayRef) {\n                        overlayRef.updateSize({ width: this.getPanelWidth() });\n                    }\n                });\n            }\n        } else {\n            const position = overlayRef.getConfig().positionStrategy as FlexibleConnectedPositionStrategy;\n\n            // Update the trigger, panel width and direction, in case anything has changed.\n            position.setOrigin(this.getConnectedElement());\n            overlayRef.updateSize({ width: this.getPanelWidth() });\n        }\n\n        if (overlayRef && !overlayRef.hasAttached()) {\n            overlayRef.attach(this.portal);\n            this.closingActionsSubscription = this.subscribeToClosingActions();\n        }\n\n        const wasOpen = this.panelOpen;\n\n        this.autocomplete.setVisibility();\n        this.autocomplete.isOpen = this.overlayAttached = true;\n\n        // We need to do an extra `panelOpen` check in here, because the\n        // autocomplete won't be shown if there are no options.\n        if (this.panelOpen && wasOpen !== this.panelOpen) {\n            this.autocomplete.opened.emit();\n        }\n    }\n\n    private getOverlayConfig(): OverlayConfig {\n        return new OverlayConfig({\n            positionStrategy: this.getOverlayPosition(),\n            scrollStrategy: this.scrollStrategy(),\n            width: this.getPanelWidth(),\n            direction: this.dir\n        });\n    }\n\n    private getOverlayPosition(): PositionStrategy {\n        this.positionStrategy = this.overlay.position()\n            .flexibleConnectedTo(this.getConnectedElement())\n            .withFlexibleDimensions(false)\n            .withPush(false)\n            .withPositions([\n                {\n                    originX: 'start',\n                    originY: 'bottom',\n                    overlayX: 'start',\n                    overlayY: 'top'\n                },\n                {\n                    originX: 'start',\n                    originY: 'top',\n                    overlayX: 'start',\n                    overlayY: 'bottom',\n\n                    // The overlay edge connected to the trigger should have squared corners, while\n                    // the opposite end has rounded corners. We apply a CSS class to swap the\n                    // border-radius based on the overlay position.\n                    panelClass: 'mc-autocomplete-panel-above'\n                }\n            ] as ConnectedPosition[]);\n\n        return this.positionStrategy;\n    }\n\n    private getConnectedElement(): ElementRef<HTMLElement> {\n        if (this.connectedTo) {\n            return this.connectedTo.elementRef;\n        }\n\n        return this.formField ? this.formField.getConnectedOverlayOrigin() : this.elementRef;\n    }\n\n    private getPanelWidth(): number | string {\n        return this.autocomplete.panelWidth || this.getHostWidth() - AUTOCOMPLETE_BORDER_WIDTH;\n    }\n\n    private getHostWidth(): number {\n        return this.getConnectedElement().nativeElement.getBoundingClientRect().width;\n    }\n\n    /**\n     * Resets the active item to -1 so arrow events will activate the\n     * correct options, or to 0 if the consumer opted into it.\n     */\n    private resetActiveItem(): void {\n        if (this.autocomplete.autoActiveFirstOption) {\n            this.autocomplete.keyManager.setFirstItemActive();\n        } else {\n            this.autocomplete.keyManager.setActiveItem(-1);\n        }\n    }\n\n    private canOpen(): boolean {\n        const element = this.elementRef.nativeElement;\n\n        return !element.readOnly && !element.disabled && !this._autocompleteDisabled;\n    }\n}\n","import { OverlayModule } from '@angular/cdk/overlay';\nimport { CommonModule } from '@angular/common';\nimport { NgModule } from '@angular/core';\nimport { McOptionModule, McCommonModule } from '@ptsecurity/mosaic/core';\n\nimport { McAutocompleteOrigin } from './autocomplete-origin.directive';\nimport {\n    McAutocompleteTrigger,\n    MC_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY_PROVIDER\n} from './autocomplete-trigger.directive';\nimport { McAutocomplete } from './autocomplete.component';\n\n\n@NgModule({\n    imports: [McOptionModule, OverlayModule, McCommonModule, CommonModule],\n    exports: [\n        McAutocomplete,\n        McOptionModule,\n        McAutocompleteTrigger,\n        McAutocompleteOrigin,\n        McCommonModule\n    ],\n    declarations: [McAutocomplete, McAutocompleteTrigger, McAutocompleteOrigin],\n    providers: [MC_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY_PROVIDER]\n})\nexport class McAutocompleteModule {}\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './index';\n"]}
{"version":3,"sources":["webpack:///dist/packages/mosaic/autocomplete/autocomplete.component.ts","webpack:///dist/packages/mosaic/autocomplete/autocomplete-origin.directive.ts","webpack:///dist/packages/mosaic/autocomplete/autocomplete-trigger.directive.ts","webpack:///dist/packages/mosaic/autocomplete/autocomplete.module.ts","webpack:///dist/packages/mosaic/autocomplete/ptsecurity-mosaic-autocomplete.ts"],"names":["uniqueAutocompleteIdCounter","McAutocompleteSelectedEvent","source","option","MC_AUTOCOMPLETE_DEFAULT_OPTIONS","providedIn","factory","MC_AUTOCOMPLETE_DEFAULT_OPTIONS_FACTORY","autoActiveFirstOption","McAutocomplete","changeDetectorRef","elementRef","defaults","id","showPanel","displayWith","optionSelected","opened","closed","_classList","_isOpen","_openOnFocus","_autoActiveFirstOption","value","length","split","forEach","className","trim","nativeElement","keyManager","options","setVisibility","scrollTop","panel","markForCheck","event","emit","onKeydown","descendants","McAutocompleteOrigin","AUTOCOMPLETE_OPTION_HEIGHT","AUTOCOMPLETE_PANEL_HEIGHT","AUTOCOMPLETE_BORDER_WIDTH","MC_AUTOCOMPLETE_SCROLL_STRATEGY","MC_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY","overlay","scrollStrategies","reposition","MC_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY_PROVIDER","provide","deps","useFactory","MAT_AUTOCOMPLETE_VALUE_ACCESSOR","useExisting","McAutocompleteTrigger","multi","getMcAutocompleteMissingPanelError","Error","viewContainerRef","zone","scrollStrategy","dir","formField","document","viewportRuler","optionSelections","autocomplete","map","onSelectionChange","onStable","asObservable","pipe","autocompleteAttribute","_autocompleteDisabled","overlayAttached","componentDestroyed","viewportSubscription","EMPTY","canOpenOnNextFocus","closeKeyEventStream","onChange","onTouched","windowBlurHandler","activeElement","panelOpen","window","runOutsideAngular","addEventListener","activeItem","removeEventListener","unsubscribe","destroyPanel","complete","attachOverlay","isOpen","overlayRef","hasAttached","detach","closingActionsSubscription","detectChanges","updatePosition","tabOut","getOutsideClickStream","detachments","observableOf","Promise","resolve","then","setTriggerValue","fn","isDisabled","disabled","keyCode","preventDefault","activeOption","selectViaInteraction","resetActiveItem","prevActiveItem","canOpen","openPanel","isArrowKey","scrollToOption","target","type","parseFloat","previousValue","openOnFocus","$event","clickTarget","_elementRef","customOrigin","connectedTo","contains","overlayElement","index","activeItemIndex","labelCount","optionGroups","newScrollPosition","getScrollTop","setScrollTop","firstStable","optionChanges","changes","positionStrategy","reapplyLastPosition","wasOpen","panelClosingActions","subscribe","setValueAndClose","closePanel","dispose","toDisplay","inputValue","control","clearPreviousSelectedOption","focus","emitSelectEvent","skip","selected","deselect","portal","template","create","getOverlayConfig","keydownEvents","altKey","next","change","updateSize","width","getPanelWidth","position","getConfig","setOrigin","getConnectedElement","attach","subscribeToClosingActions","getOverlayPosition","direction","flexibleConnectedTo","withFlexibleDimensions","withPush","withPositions","originX","originY","overlayX","overlayY","panelClass","getConnectedOverlayOrigin","panelWidth","getHostWidth","getBoundingClientRect","setFirstItemActive","setActiveItem","element","readOnly","McAutocompleteModule"],"mappings":"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","file":"3-es5.js","sourcesContent":["import { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport {\n    AfterContentInit,\n    ChangeDetectionStrategy,\n    ChangeDetectorRef,\n    Component,\n    ContentChildren,\n    ElementRef,\n    EventEmitter,\n    Inject,\n    InjectionToken,\n    Input,\n    Output,\n    QueryList,\n    TemplateRef,\n    ViewChild,\n    ViewEncapsulation\n} from '@angular/core';\nimport { ActiveDescendantKeyManager } from '@ptsecurity/cdk/a11y';\nimport { MC_OPTION_PARENT_COMPONENT, McOptgroup, McOption } from '@ptsecurity/mosaic/core';\n\n\n/**\n * Autocomplete IDs need to be unique across components, so this counter exists outside of\n * the component definition.\n */\nlet uniqueAutocompleteIdCounter = 0;\n\nexport class McAutocompleteSelectedEvent {\n    constructor(public source: McAutocomplete, public option: McOption) {}\n}\n\n/** Default `mc-autocomplete` options that can be overridden. */\n// tslint:disable-next-line naming-convention\nexport interface McAutocompleteDefaultOptions {\n    /** Whether the first option should be highlighted when an autocomplete panel is opened. */\n    autoActiveFirstOption?: boolean;\n}\n\n/** Injection token to be used to override the default options for `mc-autocomplete`. */\nexport const MC_AUTOCOMPLETE_DEFAULT_OPTIONS =\n    new InjectionToken<McAutocompleteDefaultOptions>('mc-autocomplete-default-options', {\n        providedIn: 'root',\n        factory: MC_AUTOCOMPLETE_DEFAULT_OPTIONS_FACTORY\n    });\n\n// tslint:disable-next-line naming-convention\nexport function MC_AUTOCOMPLETE_DEFAULT_OPTIONS_FACTORY(): McAutocompleteDefaultOptions {\n    return { autoActiveFirstOption: true };\n}\n\n@Component({\n    selector: 'mc-autocomplete',\n    exportAs: 'mcAutocomplete',\n    templateUrl: 'autocomplete.html',\n    styleUrls: ['autocomplete.scss'],\n    host: {\n        class: 'mc-autocomplete'\n    },\n    encapsulation: ViewEncapsulation.None,\n    changeDetection: ChangeDetectionStrategy.OnPush,\n    providers: [{\n        provide: MC_OPTION_PARENT_COMPONENT, useExisting: McAutocomplete\n    }]\n})\nexport class McAutocomplete implements AfterContentInit {\n    /** Unique ID to be used by autocomplete trigger's \"aria-owns\" property. */\n    id: string = `mc-autocomplete-${uniqueAutocompleteIdCounter++}`;\n\n    /** Manages active item in option list based on key events. */\n    keyManager: ActiveDescendantKeyManager<McOption>;\n\n    /** Whether the autocomplete panel should be visible, depending on option length. */\n    showPanel: boolean = false;\n\n    @ViewChild(TemplateRef, {static: true}) template: TemplateRef<any>;\n\n    @ViewChild('panel', {static: false}) panel: ElementRef;\n\n    @ContentChildren(McOption, { descendants: true }) options: QueryList<McOption>;\n\n    @ContentChildren(McOptgroup) optionGroups: QueryList<McOptgroup>;\n\n    /** Function that maps an option's control value to its display value in the trigger. */\n    @Input() displayWith: ((value: any) => string) | null = null;\n\n    /**\n     * Specify the width of the autocomplete panel.  Can be any CSS sizing value, otherwise it will\n     * match the width of its host.\n     */\n    @Input() panelWidth: string | number;\n\n    /** Event that is emitted whenever an option from the list is selected. */\n    @Output() readonly optionSelected: EventEmitter<McAutocompleteSelectedEvent> =\n        new EventEmitter<McAutocompleteSelectedEvent>();\n\n    /** Event that is emitted when the autocomplete panel is opened. */\n    @Output() readonly opened: EventEmitter<void> = new EventEmitter<void>();\n\n    /** Event that is emitted when the autocomplete panel is closed. */\n    @Output() readonly closed: EventEmitter<void> = new EventEmitter<void>();\n\n    /**\n     * Takes classes set on the host mc-autocomplete element and applies them to the panel\n     * inside the overlay container to allow for easy styling.\n     */\n    @Input('class')\n    get classList() {\n        return this._classList;\n    }\n\n    set classList(value: string) {\n        if (value && value.length) {\n            value.split(' ')\n                .forEach((className) => this._classList[className.trim()] = true);\n\n            this.elementRef.nativeElement.className = '';\n        }\n    }\n\n    private _classList: any = {};\n\n    /**\n     * Whether the first option should be highlighted when the autocomplete panel is opened.\n     * Can be configured globally through the `MC_AUTOCOMPLETE_DEFAULT_OPTIONS` token.\n     */\n    @Input()\n    get autoActiveFirstOption(): boolean {\n        return this._autoActiveFirstOption;\n    }\n\n    set autoActiveFirstOption(value: boolean) {\n        this._autoActiveFirstOption = coerceBooleanProperty(value);\n    }\n\n    private _autoActiveFirstOption: boolean;\n\n    get isOpen(): boolean {\n        return this._isOpen && this.showPanel;\n    }\n\n    set isOpen(value: boolean) {\n        this._isOpen = value;\n    }\n\n    private _isOpen: boolean = false;\n\n    @Input()\n    get openOnFocus(): boolean {\n        return this._openOnFocus;\n    }\n\n    set openOnFocus(value: boolean) {\n        this._openOnFocus = value;\n    }\n\n    private _openOnFocus: boolean = true;\n\n    constructor(\n        private changeDetectorRef: ChangeDetectorRef,\n        private elementRef: ElementRef<HTMLElement>,\n        @Inject(MC_AUTOCOMPLETE_DEFAULT_OPTIONS) defaults: McAutocompleteDefaultOptions\n    ) {\n        this._autoActiveFirstOption = !!defaults.autoActiveFirstOption;\n    }\n\n    ngAfterContentInit() {\n        this.keyManager = new ActiveDescendantKeyManager<McOption>(this.options);\n        this.setVisibility();\n    }\n\n    setScrollTop(scrollTop: number): void {\n        if (this.panel) {\n            this.panel.nativeElement.scrollTop = scrollTop;\n        }\n    }\n\n    getScrollTop(): number {\n        return this.panel ? this.panel.nativeElement.scrollTop : 0;\n    }\n\n    setVisibility() {\n        this.showPanel = !!this.options.length;\n        this._classList['mc-autocomplete_visible'] = this.showPanel;\n        this._classList['mc-autocomplete_hidden'] = !this.showPanel;\n\n        this.changeDetectorRef.markForCheck();\n    }\n\n    emitSelectEvent(option: McOption): void {\n        const event = new McAutocompleteSelectedEvent(this, option);\n\n        this.optionSelected.emit(event);\n    }\n\n    onKeydown(event: KeyboardEvent): any {\n        this.keyManager.onKeydown(event);\n    }\n}\n","import { Directive, ElementRef } from '@angular/core';\n\n\n/**\n * Directive applied to an element to make it usable\n * as a connection point for an autocomplete panel.\n */\n@Directive({\n    selector: '[mcAutocompleteOrigin]',\n    exportAs: 'mcAutocompleteOrigin'\n})\nexport class McAutocompleteOrigin {\n    constructor(public elementRef: ElementRef<HTMLElement>) {}\n}\n","import { Directionality } from '@angular/cdk/bidi';\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport {\n    ConnectedPosition,\n    FlexibleConnectedPositionStrategy,\n    Overlay,\n    OverlayConfig,\n    OverlayRef,\n    PositionStrategy,\n    ScrollStrategy\n} from '@angular/cdk/overlay';\nimport { TemplatePortal } from '@angular/cdk/portal';\nimport { ViewportRuler } from '@angular/cdk/scrolling';\nimport { DOCUMENT } from '@angular/common';\nimport {\n    ChangeDetectorRef,\n    Directive,\n    ElementRef,\n    forwardRef,\n    Host,\n    Inject,\n    InjectionToken,\n    Input,\n    NgZone,\n    OnDestroy,\n    Optional,\n    ViewContainerRef\n} from '@angular/core';\nimport { ControlValueAccessor, NG_VALUE_ACCESSOR } from '@angular/forms';\nimport { DOWN_ARROW, ENTER, ESCAPE, TAB, UP_ARROW } from '@ptsecurity/cdk/keycodes';\nimport {\n    countGroupLabelsBeforeOption,\n    getOptionScrollPosition,\n    McOption,\n    McOptionSelectionChange\n} from '@ptsecurity/mosaic/core';\nimport { McFormField } from '@ptsecurity/mosaic/form-field';\nimport { Subscription, defer, fromEvent, merge, of as observableOf, Subject, Observable } from 'rxjs';\nimport { filter, take, switchMap, delay, tap, map } from 'rxjs/operators';\n\nimport { McAutocompleteOrigin } from './autocomplete-origin.directive';\nimport { McAutocomplete } from './autocomplete.component';\n\n\n/**\n * The following style constants are necessary to save here in order\n * to properly calculate the scrollTop of the panel. Because we are not\n * actually focusing the active item, scroll must be handled manually.\n */\n\n/** The height of each autocomplete option. */\nexport const AUTOCOMPLETE_OPTION_HEIGHT = 32;\n\n/** The total height of the autocomplete panel. */\nexport const AUTOCOMPLETE_PANEL_HEIGHT = 256;\n\nexport const AUTOCOMPLETE_BORDER_WIDTH: number = 2;\n\n/** Injection token that determines the scroll handling while the autocomplete panel is open. */\nexport const MC_AUTOCOMPLETE_SCROLL_STRATEGY =\n    new InjectionToken<() => ScrollStrategy>('mc-autocomplete-scroll-strategy');\n\n// tslint:disable-next-line naming-convention\nexport function MC_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY(overlay: Overlay): () => ScrollStrategy {\n    return () => overlay.scrollStrategies.reposition();\n}\n\nexport const MC_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY_PROVIDER = {\n    provide: MC_AUTOCOMPLETE_SCROLL_STRATEGY,\n    deps: [Overlay],\n    useFactory: MC_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY\n};\n\n/**\n * Provider that allows the autocomplete to register as a ControlValueAccessor.\n * @docs-private\n */\nexport const MAT_AUTOCOMPLETE_VALUE_ACCESSOR: any = {\n    provide: NG_VALUE_ACCESSOR,\n    useExisting: forwardRef(() => McAutocompleteTrigger),\n    multi: true\n};\n\n/**\n * Creates an error to be thrown when attempting to use an autocomplete trigger without a panel.\n * @docs-private\n */\nexport function getMcAutocompleteMissingPanelError(): Error {\n    return Error('Attempting to open an undefined instance of `mc-autocomplete`. ' +\n        'Make sure that the id passed to the `mcAutocomplete` is correct and that ' +\n        'you\\'re attempting to open it after the ngAfterContentInit hook.');\n}\n\n\n@Directive({\n    selector: `input[mcAutocomplete], textarea[mcAutocomplete]`,\n    host: {\n        class: 'mc-autocomplete-trigger',\n        '[attr.autocomplete]': 'autocompleteAttribute',\n        // Note: we use `focusin`, as opposed to `focus`, in order to open the panel\n        // a little earlier. This avoids issues where IE delays the focusing of the input.\n        '(focusin)': 'handleFocus()',\n        '(blur)': 'onTouched()',\n        '(input)': 'handleInput($event)',\n        '(keydown)': 'handleKeydown($event)',\n        '(click)': 'handleClick($event)'\n    },\n    exportAs: 'mcAutocompleteTrigger',\n    providers: [MAT_AUTOCOMPLETE_VALUE_ACCESSOR]\n})\nexport class McAutocompleteTrigger implements ControlValueAccessor, OnDestroy {\n    // @ts-ignore\n    readonly optionSelections: Observable<McOptionSelectionChange> = defer(() => {\n        if (this.autocomplete && this.autocomplete.options) {\n            return merge(...this.autocomplete.options.map((option) => option.onSelectionChange));\n        }\n\n        // If there are any subscribers before `ngAfterViewInit`, the `autocomplete` will be undefined.\n        // Return a stream that we'll replace with the real one once everything is in place.\n        return this.zone.onStable\n            .asObservable()\n            .pipe(take(1), switchMap(() => this.optionSelections));\n    });\n\n    /** The currently active option, coerced to MatOption type. */\n    get activeOption(): McOption | null {\n        if (this.autocomplete && this.autocomplete.keyManager) {\n            return this.autocomplete.keyManager.activeItem;\n        }\n\n        return null;\n    }\n\n    get panelOpen(): boolean {\n        return this.overlayAttached && this.autocomplete.showPanel;\n    }\n\n    /** The autocomplete panel to be attached to this trigger. */\n    @Input('mcAutocomplete') autocomplete: McAutocomplete;\n\n    /**\n     * Reference relative to which to position the autocomplete panel.\n     * Defaults to the autocomplete trigger element.\n     */\n    @Input('mcAutocompleteConnectedTo') connectedTo: McAutocompleteOrigin;\n\n    /**\n     * `autocomplete` attribute to be set on the input element.\n     * @docs-private\n     */\n    @Input('autocomplete') autocompleteAttribute: string = 'off';\n\n    /**\n     * Whether the autocomplete is disabled. When disabled, the element will\n     * act as a regular input and the user won't be able to open the panel.\n     */\n    @Input('mcAutocompleteDisabled')\n    get autocompleteDisabled(): boolean {\n        return this._autocompleteDisabled;\n    }\n\n    set autocompleteDisabled(value: boolean) {\n        this._autocompleteDisabled = coerceBooleanProperty(value);\n    }\n\n    private _autocompleteDisabled = false;\n\n    private overlayAttached: boolean = false;\n\n    private overlayRef: OverlayRef | null;\n\n    private portal: TemplatePortal;\n\n    private componentDestroyed = false;\n\n    private scrollStrategy: () => ScrollStrategy;\n\n    /** Old value of the native input. Used to work around issues with the `input` event on IE. */\n    private previousValue: string | number | null;\n\n    /** Strategy that is used to position the panel. */\n    private positionStrategy: FlexibleConnectedPositionStrategy;\n\n    /** The subscription for closing actions (some are bound to document). */\n    private closingActionsSubscription: Subscription;\n\n    /** Subscription to viewport size changes. */\n    private viewportSubscription = Subscription.EMPTY;\n\n    /**\n     * Whether the autocomplete can open the next time it is focused. Used to prevent a focused,\n     * closed autocomplete from being reopened if the user switches to another browser tab and then\n     * comes back.\n     */\n    private canOpenOnNextFocus = true;\n\n    /** Stream of keyboard events that can close the panel. */\n    private readonly closeKeyEventStream = new Subject<void>();\n\n    constructor(\n        private elementRef: ElementRef<HTMLInputElement>,\n        private viewContainerRef: ViewContainerRef,\n        private changeDetectorRef: ChangeDetectorRef,\n        private overlay: Overlay,\n        private zone: NgZone,\n        @Inject(MC_AUTOCOMPLETE_SCROLL_STRATEGY) scrollStrategy: any,\n        @Optional() private dir: Directionality,\n        @Optional() @Host() private formField: McFormField,\n        @Optional() @Inject(DOCUMENT) private document: any,\n        // @breaking-change 8.0.0 Make `_viewportRuler` required.\n        private viewportRuler?: ViewportRuler\n    ) {\n        // tslint:disable-next-line no-typeof-undefined\n        if (typeof window !== 'undefined') {\n            zone.runOutsideAngular(() => {\n                window.addEventListener('blur', this.windowBlurHandler);\n            });\n        }\n\n        this.scrollStrategy = scrollStrategy;\n    }\n\n    ngOnDestroy() {\n        // tslint:disable-next-line no-typeof-undefined\n        if (typeof window !== 'undefined') {\n            window.removeEventListener('blur', this.windowBlurHandler);\n        }\n\n        this.viewportSubscription.unsubscribe();\n        this.componentDestroyed = true;\n        this.destroyPanel();\n        this.closeKeyEventStream.complete();\n    }\n\n    /** `View -> model callback called when value changes` */\n    // tslint:disable-next-line no-empty\n    onChange: (value: any) => void = () => {};\n\n    /** `View -> model callback called when autocomplete has been touched` */\n    // tslint:disable-next-line no-empty\n    onTouched: () => void = () => {};\n\n    /** Opens the autocomplete suggestion panel. */\n    openPanel(): void {\n        this.attachOverlay();\n    }\n\n    closePanel(): void {\n        if (!this.overlayAttached) { return; }\n\n        if (this.panelOpen) {\n            this.autocomplete.closed.emit();\n        }\n\n        this.autocomplete.isOpen = this.overlayAttached = false;\n\n        if (this.overlayRef && this.overlayRef.hasAttached()) {\n            this.overlayRef.detach();\n            this.closingActionsSubscription.unsubscribe();\n        }\n\n        // Note that in some cases this can end up being called after the component is destroyed.\n        // Add a check to ensure that we don't try to run change detection on a destroyed view.\n        if (!this.componentDestroyed) {\n            // We need to trigger change detection manually, because\n            // `fromEvent` doesn't seem to do it at the proper time.\n            // This ensures that the label is reset when the\n            // user clicks outside.\n            this.changeDetectorRef.detectChanges();\n        }\n    }\n\n    /**\n     * Updates the position of the autocomplete suggestion panel to ensure that it fits all options\n     * within the viewport.\n     */\n    updatePosition(): void {\n        if (this.overlayAttached) {\n            this.overlayRef!.updatePosition();\n        }\n    }\n\n    /**\n     * A stream of actions that should close the autocomplete panel, including\n     * when an option is selected, on blur, and when TAB is pressed.\n     */\n    get panelClosingActions(): Observable<McOptionSelectionChange | null> {\n        return merge(\n            this.optionSelections,\n            this.autocomplete.keyManager.tabOut.pipe(filter(() => this.overlayAttached)),\n            this.closeKeyEventStream,\n            this.getOutsideClickStream(),\n            this.overlayRef ?\n                this.overlayRef.detachments().pipe(filter(() => this.overlayAttached)) :\n                observableOf()\n        ).pipe(\n            // Normalize the output so we return a consistent type.\n            map((event) => event instanceof McOptionSelectionChange ? event : null)\n        );\n    }\n\n    // Implemented as part of ControlValueAccessor.\n    writeValue(value: any): void {\n        Promise.resolve(null).then(() => this.setTriggerValue(value));\n    }\n\n    // Implemented as part of ControlValueAccessor.\n    registerOnChange(fn: (value: any) => {}): void {\n        this.onChange = fn;\n    }\n\n    // Implemented as part of ControlValueAccessor.\n    registerOnTouched(fn: () => {}) {\n        this.onTouched = fn;\n    }\n\n    // Implemented as part of ControlValueAccessor.\n    setDisabledState(isDisabled: boolean) {\n        this.elementRef.nativeElement.disabled = isDisabled;\n    }\n\n    handleKeydown(event: KeyboardEvent): void {\n        // tslint:disable-next-line deprecation\n        const keyCode = event.keyCode;\n\n        // Prevent the default action on all escape key presses. This is here primarily to bring IE\n        // in line with other browsers. By default, pressing escape on IE will cause it to revert\n        // the input value to the one that it had on focus, however it won't dispatch any events\n        // which means that the model value will be out of sync with the view.\n        if (keyCode === ESCAPE) {\n            event.preventDefault();\n        }\n\n        if (this.activeOption && keyCode === ENTER && this.panelOpen) {\n            this.activeOption.selectViaInteraction();\n            this.resetActiveItem();\n            event.preventDefault();\n        } else if (this.autocomplete) {\n            const prevActiveItem = this.autocomplete.keyManager.activeItem;\n\n            if (this.panelOpen || keyCode === TAB) {\n                this.autocomplete.onKeydown(event);\n            } else if (keyCode === DOWN_ARROW && this.canOpen()) {\n                this.openPanel();\n            }\n\n            const isArrowKey = keyCode === UP_ARROW || keyCode === DOWN_ARROW;\n\n            if (isArrowKey || this.autocomplete.keyManager.activeItem !== prevActiveItem) {\n                this.scrollToOption();\n            }\n        }\n    }\n\n    handleInput(event: KeyboardEvent): void {\n        const target = event.target as HTMLInputElement;\n        let value: number | string | null = target.value;\n\n        // Based on `NumberValueAccessor` from forms.\n        if (target.type === 'number') {\n            value = value === '' ? null : parseFloat(value);\n        }\n\n        // If the input has a placeholder, IE will fire the `input` event on page load,\n        // focus and blur, in addition to when the user actually changed the value. To\n        // filter out all of the extra events, we save the value on focus and between\n        // `input` events, and we check whether it changed.\n        // See: https://connect.microsoft.com/IE/feedback/details/885747/\n        if (this.previousValue !== value) {\n            this.previousValue = value;\n            this.onChange(value);\n\n            if (this.canOpen() && this.document.activeElement === event.target) {\n                this.openPanel();\n            }\n        }\n    }\n\n    handleFocus(): void {\n        if (!this.canOpenOnNextFocus) {\n            this.canOpenOnNextFocus = true;\n        } else if (this.canOpen() && this.autocomplete.openOnFocus) {\n            this.previousValue = this.elementRef.nativeElement.value;\n            this.attachOverlay();\n        }\n    }\n\n    handleClick($event: MouseEvent) {\n        if (this.canOpen() && this.document.activeElement === $event.target) {\n            this.openPanel();\n        }\n    }\n\n    /** Stream of clicks outside of the autocomplete panel. */\n    private getOutsideClickStream(): Observable<any> {\n        return merge(\n            // tslint:disable-next-line: no-unnecessary-type-assertion\n            fromEvent(this.document, 'click') as Observable<MouseEvent>,\n            // tslint:disable-next-line: no-unnecessary-type-assertion\n            fromEvent(this.document, 'touchend') as Observable<TouchEvent>\n        )\n            .pipe(filter((event) => {\n\n                const clickTarget = event.target as HTMLElement;\n                const formField = this.formField ? this.formField._elementRef.nativeElement : null;\n                const customOrigin = this.connectedTo ? this.connectedTo.elementRef.nativeElement : null;\n\n                return this.overlayAttached &&\n                    clickTarget !== this.elementRef.nativeElement &&\n                    (!formField || !formField.contains(clickTarget)) &&\n                    (!customOrigin || !customOrigin.contains(clickTarget)) &&\n                    (!!this.overlayRef && !this.overlayRef.overlayElement.contains(clickTarget));\n            }));\n    }\n\n    /**\n     * Event handler for when the window is blurred. Needs to be an\n     * arrow function in order to preserve the context.\n     */\n    private windowBlurHandler = () => {\n        // If the user blurred the window while the autocomplete is focused, it means that it'll be\n        // refocused when they come back. In this case we want to skip the first focus event, if the\n        // pane was closed, in order to avoid reopening it unintentionally.\n        this.canOpenOnNextFocus = this.document.activeElement !== this.elementRef.nativeElement || this.panelOpen;\n    }\n\n    /**\n     * Given that we are not actually focusing active options, we must manually adjust scroll\n     * to reveal options below the fold. First, we find the offset of the option from the top\n     * of the panel. If that offset is below the fold, the new scrollTop will be the offset -\n     * the panel height + the option height, so the active option will be just visible at the\n     * bottom of the panel. If that offset is above the top of the visible panel, the new scrollTop\n     * will become the offset. If that offset is visible within the panel already, the scrollTop is\n     * not adjusted.\n     */\n    private scrollToOption(): void {\n        const index = this.autocomplete.keyManager.activeItemIndex || 0;\n        const labelCount = countGroupLabelsBeforeOption(\n            index,\n            this.autocomplete.options, this.autocomplete.optionGroups\n        );\n\n        const newScrollPosition = getOptionScrollPosition(\n            index + labelCount,\n            AUTOCOMPLETE_OPTION_HEIGHT,\n            this.autocomplete.getScrollTop(),\n            AUTOCOMPLETE_PANEL_HEIGHT\n        );\n\n        this.autocomplete.setScrollTop(newScrollPosition);\n    }\n\n    /**\n     * This method listens to a stream of panel closing actions and resets the\n     * stream every time the option list changes.\n     */\n    private subscribeToClosingActions(): Subscription {\n        const firstStable = this.zone.onStable.asObservable()\n            .pipe(take(1));\n        const optionChanges = this.autocomplete.options.changes\n            .pipe(\n                tap(() => this.positionStrategy.reapplyLastPosition()),\n                // Defer emitting to the stream until the next tick, because changing\n                // bindings in here will cause \"changed after checked\" errors.\n                delay(0)\n            );\n\n        // When the zone is stable initially, and when the option list changes...\n        return merge(firstStable, optionChanges)\n            .pipe(\n                // create a new stream of panelClosingActions, replacing any previous streams\n                // that were created, and flatten it so our stream only emits closing events...\n                switchMap(() => {\n                    const wasOpen = this.panelOpen;\n                    this.resetActiveItem();\n                    this.autocomplete.setVisibility();\n\n                    if (this.panelOpen) {\n                        this.overlayRef!.updatePosition();\n\n                        // If the `panelOpen` state changed, we need to make sure to emit the `opened`\n                        // event, because we may not have emitted it when the panel was attached. This\n                        // can happen if the users opens the panel and there are no options, but the\n                        // options come in slightly later or as a result of the value changing.\n                        if (wasOpen !== this.panelOpen) {\n                            this.autocomplete.opened.emit();\n                        }\n                    }\n\n                    return this.panelClosingActions;\n                }),\n                // when the first closing event occurs...\n                take(1)\n            )\n            // set the value, close the panel, and complete.\n            .subscribe((event) => this.setValueAndClose(event));\n    }\n\n    /** Destroys the autocomplete suggestion panel. */\n    private destroyPanel(): void {\n        if (this.overlayRef) {\n            this.closePanel();\n            this.overlayRef.dispose();\n            this.overlayRef = null;\n        }\n    }\n\n    private setTriggerValue(value: any): void {\n        const toDisplay = this.autocomplete && this.autocomplete.displayWith ?\n            this.autocomplete.displayWith(value) :\n            value;\n\n        // Simply falling back to an empty string if the display value is falsy does not work properly.\n        // The display value can also be the number zero and shouldn't fall back to an empty string.\n        const inputValue = toDisplay != null ? toDisplay : '';\n\n        // If it's used within a `MatFormField`, we should set it through the property so it can go\n        // through change detection.\n        if (this.formField) {\n            this.formField.control.value = inputValue;\n        } else {\n            this.elementRef.nativeElement.value = inputValue;\n        }\n\n        this.previousValue = inputValue;\n    }\n\n    /** This method closes the panel, and if a value is specified, also sets the associated\n     * control to that value. It will also mark the control as dirty if this interaction\n     * stemmed from the user.\n     */\n    private setValueAndClose(event: McOptionSelectionChange | null): void {\n        if (event && event.source) {\n            this.clearPreviousSelectedOption(event.source);\n            this.setTriggerValue(event.source.value);\n            this.onChange(event.source.value);\n            this.elementRef.nativeElement.focus();\n\n            this.autocomplete.emitSelectEvent(event.source);\n        }\n\n        this.closePanel();\n    }\n\n    /** Clear any previous selected option and emit a selection change event for this option */\n    private clearPreviousSelectedOption(skip: McOption) {\n        this.autocomplete.options.forEach((option) => {\n            if (option !== skip && option.selected) {\n                option.deselect();\n            }\n        });\n    }\n\n    private attachOverlay(): void {\n        if (!this.autocomplete) {\n            throw getMcAutocompleteMissingPanelError();\n        }\n\n        let overlayRef = this.overlayRef;\n\n        if (!overlayRef) {\n            this.portal = new TemplatePortal(this.autocomplete.template, this.viewContainerRef);\n            overlayRef = this.overlay.create(this.getOverlayConfig());\n            this.overlayRef = overlayRef;\n\n            // Use the `keydownEvents` in order to take advantage of\n            // the overlay event targeting provided by the CDK overlay.\n            overlayRef.keydownEvents().subscribe((event) => {\n                // Close when pressing ESCAPE or ALT + UP_ARROW, based on the a11y guidelines.\n                // See: https://www.w3.org/TR/wai-aria-practices-1.1/#textbox-keyboard-interaction\n                // tslint:disable-next-line deprecation\n                if (event.keyCode === ESCAPE || (event.keyCode === UP_ARROW && event.altKey)) {\n                    this.resetActiveItem();\n                    this.closeKeyEventStream.next();\n                }\n            });\n\n            if (this.viewportRuler) {\n                this.viewportSubscription = this.viewportRuler.change().subscribe(() => {\n                    if (this.panelOpen && overlayRef) {\n                        overlayRef.updateSize({ width: this.getPanelWidth() });\n                    }\n                });\n            }\n        } else {\n            const position = overlayRef.getConfig().positionStrategy as FlexibleConnectedPositionStrategy;\n\n            // Update the trigger, panel width and direction, in case anything has changed.\n            position.setOrigin(this.getConnectedElement());\n            overlayRef.updateSize({ width: this.getPanelWidth() });\n        }\n\n        if (overlayRef && !overlayRef.hasAttached()) {\n            overlayRef.attach(this.portal);\n            this.closingActionsSubscription = this.subscribeToClosingActions();\n        }\n\n        const wasOpen = this.panelOpen;\n\n        this.autocomplete.setVisibility();\n        this.autocomplete.isOpen = this.overlayAttached = true;\n\n        // We need to do an extra `panelOpen` check in here, because the\n        // autocomplete won't be shown if there are no options.\n        if (this.panelOpen && wasOpen !== this.panelOpen) {\n            this.autocomplete.opened.emit();\n        }\n    }\n\n    private getOverlayConfig(): OverlayConfig {\n        return new OverlayConfig({\n            positionStrategy: this.getOverlayPosition(),\n            scrollStrategy: this.scrollStrategy(),\n            width: this.getPanelWidth(),\n            direction: this.dir\n        });\n    }\n\n    private getOverlayPosition(): PositionStrategy {\n        this.positionStrategy = this.overlay.position()\n            .flexibleConnectedTo(this.getConnectedElement())\n            .withFlexibleDimensions(false)\n            .withPush(false)\n            .withPositions([\n                {\n                    originX: 'start',\n                    originY: 'bottom',\n                    overlayX: 'start',\n                    overlayY: 'top'\n                },\n                {\n                    originX: 'start',\n                    originY: 'top',\n                    overlayX: 'start',\n                    overlayY: 'bottom',\n\n                    // The overlay edge connected to the trigger should have squared corners, while\n                    // the opposite end has rounded corners. We apply a CSS class to swap the\n                    // border-radius based on the overlay position.\n                    panelClass: 'mc-autocomplete-panel-above'\n                }\n            ] as ConnectedPosition[]);\n\n        return this.positionStrategy;\n    }\n\n    private getConnectedElement(): ElementRef<HTMLElement> {\n        if (this.connectedTo) {\n            return this.connectedTo.elementRef;\n        }\n\n        return this.formField ? this.formField.getConnectedOverlayOrigin() : this.elementRef;\n    }\n\n    private getPanelWidth(): number | string {\n        return this.autocomplete.panelWidth || this.getHostWidth() - AUTOCOMPLETE_BORDER_WIDTH;\n    }\n\n    private getHostWidth(): number {\n        return this.getConnectedElement().nativeElement.getBoundingClientRect().width;\n    }\n\n    /**\n     * Resets the active item to -1 so arrow events will activate the\n     * correct options, or to 0 if the consumer opted into it.\n     */\n    private resetActiveItem(): void {\n        if (this.autocomplete.autoActiveFirstOption) {\n            this.autocomplete.keyManager.setFirstItemActive();\n        } else {\n            this.autocomplete.keyManager.setActiveItem(-1);\n        }\n    }\n\n    private canOpen(): boolean {\n        const element = this.elementRef.nativeElement;\n\n        return !element.readOnly && !element.disabled && !this._autocompleteDisabled;\n    }\n}\n","import { OverlayModule } from '@angular/cdk/overlay';\nimport { CommonModule } from '@angular/common';\nimport { NgModule } from '@angular/core';\nimport { McOptionModule, McCommonModule } from '@ptsecurity/mosaic/core';\n\nimport { McAutocompleteOrigin } from './autocomplete-origin.directive';\nimport {\n    McAutocompleteTrigger,\n    MC_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY_PROVIDER\n} from './autocomplete-trigger.directive';\nimport { McAutocomplete } from './autocomplete.component';\n\n\n@NgModule({\n    imports: [McOptionModule, OverlayModule, McCommonModule, CommonModule],\n    exports: [\n        McAutocomplete,\n        McOptionModule,\n        McAutocompleteTrigger,\n        McAutocompleteOrigin,\n        McCommonModule\n    ],\n    declarations: [McAutocomplete, McAutocompleteTrigger, McAutocompleteOrigin],\n    providers: [MC_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY_PROVIDER]\n})\nexport class McAutocompleteModule {}\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './index';\n"]}